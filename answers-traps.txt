Q:哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？

A:在a0-a7中存放参数，13存放在a2中。

Q:main的汇编代码中对函数f的调用在哪里？对g的调用在哪里（提示：编译器可能会将函数内联）

A：在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。从代码li a1,12可以看出，main直接计算出了结果并储存。

Q:printf函数位于哪个地址？

A:在0x630。

Q:在main中printf的jalr之后的寄存器ra中有什么值？

A:观察XV6的代码：
30: 00000097       auipc ra,0x0
34: 600080e7       jalr  1536(ra) # 630 <printf>
第一行代码：00000097H=00...0 0000 1001 0111B，对比指令格式，可见imm=0，dest=00001，opcode=0010111，对比汇编指令可知，auipc的操作码是0010111，ra寄存器代码是00001。这行代码将0x0左移12位（还是0x0）加到PC（当前为0x30）上并存入ra中，即ra中保存的是0x30。
第2行代码：600080e7H=0110 0...0 1000 0000 1110 0111B，可见imm=0110 0000 0000，rs1=00001，funct3=000，rd=00001，opcode=1100111，rs1和rd的知识码都是00001，即都为寄存器ra。这对比jalr的标准格式有所不同，可能是此两处使用寄存器相同时，汇编中可以省略rd部分。
ra中保存的是0x30，加上0x600后为0x630，即printf的地址，执行此行代码后，将跳转到printf函数执行，并将PC+4=0X34+0X4=0X38保存到ra中，供之后返回使用。

Q:运行以下代码。
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
程序的输出是什么？这是将字节映射到字符的ASCII码表。输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？

A:57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表72:r 6c:l 64:d 00:充当字符串结尾标识，因此输出为：HE110 World。若为大端存储，i应改为0x726c6400，不需改变57616。

Q:在下面的代码中，“y=”之后将打印什么（注：答案不是一个特定的值）？为什么会发生这种情况？
printf("x=%d y=%d", 3);

A:原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据。
